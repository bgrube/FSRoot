\documentclass[11pt]{article}
%\usepackage{graphicx}
\usepackage{amssymb}
%\usepackage[]{epsfig}
%\usepackage{parskip}

\textheight 8.0in
\topmargin 0.0in
\textwidth 6.5in
\oddsidemargin 0.0in
\evensidemargin 0.0in

\newcommand{\FSR}{{\tt FSRoot}}
\newcommand{\ROOT}{{\tt ROOT}}
\newcommand{\git}{{\tt git}}

\begin{document}


\title{Notes on the \FSR\ Package}
\author{Ryan Mitchell}
\date{\today}
\maketitle

\abstract{
\FSR\ is a set of utilities to help manipulate information about different Final States~(FS) produced in particle physics experiments.  The utilities are built around the CERN \ROOT\ framework.  This document provides an introduction to \FSR.}

\tableofcontents

\parindent 0pt
\parskip 10pt



%\section{Overview of \FSR}

%This is an overview of \FSR.

\section{Installation and Initial Setup}

Instructions for installation and initial setup:

(1) Download the source:
\begin{verbatim}
    > git clone https://github.com/remitche66/FSRoot.git FSRoot
\end{verbatim}

(2) Set the location of \FSR\ in your login shell script (e.g. {\tt .cshrc}):
\begin{verbatim}
    setenv FSROOT [xxxxx]/FSRoot
\end{verbatim}

(3) Also probably add the \FSR\ directory to {\tt \$DYLD\_LIBRARY\_PATH} and {\tt \$LD\_LIBRARY\_PATH}.  This allows you to compile code including \FSR\ functions.  For example:
\begin{verbatim}
     setenv DYLD_LIBRARY_PATH $DYLD_LIBRARY_PATH\:$FSROOT
     setenv   LD_LIBRARY_PATH   $LD_LIBRARY_PATH\:$FSROOT
\end{verbatim}

(4) There is usually a {\tt .rootrc} file in your home directory that \ROOT\ uses for initialization.  Add lines like these to {\tt .rootrc}, which tell \ROOT\ the location of \FSR:
\begin{verbatim}
    Unix.*.Root.DynamicPath: .:$(FSROOT):$(ROOTSYS)/lib:
    Unix.*.Root.MacroPath:   .:$(FSROOT):
\end{verbatim}

(5) Now when you open \ROOT, the \FSR\ utilities should be loaded and compiled -- you should see a message saying ``Loading the FSRoot Macros'' along with the output of the compilation.  The loading and compiling is done in the file {\tt rootlogon.C}.  This file also sets up default styles, which are not essential.  Since these might conflict with styles you have defined elsewhere, it could be worthwhile to tweak or remove these.

\section{Basic Operations:  the {\tt FSBasic} directory}

\subsection{Basic Conventions}
\label{sec:conventions}

Some \FSR\ operations on variables within a \ROOT\ {\tt TTree} assume a particular format within the tree.  

Four-vectors are assumed to take the form:
\begin{verbatim}
    [AB]EnP[CD], [AB]PxP[CD], [AB]PyP[CD], [AB]PzP[CD]
\end{verbatim}
where {\tt [CD]} is a particle label (often ``1'', ``2'', ``3'', ``2a'', etc., but also ``CM'' or ``B'' or other) and {\tt [AB]} labels the type of four-vector (for example, ``R'' for raw or ``K'' for kinematically fit or ``MC'' for Monte Carlo, etc.).  The \FSR\ code does not assume anything about the conventions for {\tt [AB]} -- they can be anything up to two characters long~(or nothing).  The final state utilities described in Sec.~\ref{sec:modes} require the final state particles appear in a given order and assume a numbering convention for {\tt [CD]}, described in Sec.~\ref{sec:modeconv}.  The utilities described in this section do not assume a specific form for {\tt [CD]} -- they can be anyting one or two characters long~(but not empty).

Variable names for run numbers, event numbers, and the $\chi^2$/dof from a kinematic fit are also hardcoded in a very limited number of places (like in the functions that rank combinations within an event by $\chi^2/dof$ described in Sec.~\ref{sec:modetree}):
\begin{verbatim}
    Run, Event, Chi2DOF
\end{verbatim}
Maybe a future version of \FSR\ could make these formats customizable.


\subsection{Basic Histogram Utilities: the {\tt FSHistogram} class}
\label{sec:hist}

Basic histogram functions are provided by the {\tt FSHistogram} class in the {\tt FSBasic} directory.  Like many other functions within \FSR, the functions within the {\tt FSHistogram} class are static member functions, so there is never a need to deal with instances of {\tt FSHistogram}.

The basic functionality is through the {\tt FSHistogram::getTH1F} and {\tt FSHistogram::getTH2F} classes.  Here are example uses that can be run from either the \ROOT\ command line or from a macro~(see {\tt Examples/Intro/intro.C}).  The first draws a 1d histogram and the second draws a 2d histogram.  The third argument is the variable to plot; the fourth holds the number of bins and bounds.
\begin{verbatim}
    > FSHistogram::getTH1F(FileName,TreeName,"Chi2DOF","(60,0.0,6.0)","")->Draw();
    > FSHistogram::getTH2F(FileName,TreeName,"Chi2DOF:Event",
          "(100,0.0,1.0e6,60,0.0,6.0)","")->Draw("colz");
\end{verbatim}
Cuts can be added in the fifth argument:
\begin{verbatim}
    > FSHistogram::getTH1F(FileName,TreeName,"Chi2DOF",
        "(60,0.0,6.0)","Chi2DOF<5.0")->Draw();
\end{verbatim}
The variable and cut arguments can contain shortcuts.  For example, {\tt MASS(I,J)} is expanded into the total invariant mass of particles {\tt I} and {\tt J}, where {\tt I} and {\tt J} are not necessarily numbers~(they are the {\tt [CD]} in Sec.~\ref{sec:conventions}).  Characters in front of {\tt MASS}~(for example) are prepended to the variable names (the {\tt [AB]} in Sec.~\ref{sec:conventions}).  This is all done in the function {\tt FSTree::expandVariable}, which can also be used on its own to explicitly see what it is doing.    See {\tt FSTree::expandVariable} for more options beyond {\tt MASS}~(for example, {\tt RECOILMASS}, {\tt MOMENTUM}, {\tt COSINE}, etc.).  Examples:
\begin{verbatim}
    > FSHistogram::getTH1F(FileName,TreeName,"MASS(1,2)",
        "(60,0.0,6.0)","Chi2DOF<5.0&&RMASS(2,3)>1.0")->Draw();
    > cout << FSTree::expandVariable("MASS(1,2)+MASS(2,3)") << endl;
      // ==> "(sqrt((EnP1+EnP2)**2-(PxP1+PxP2)**2-(PyP1+PyP2)**2-(PzP1+PzP2)**2))
             +(sqrt((EnP2+EnP3)**2-(PxP2+PxP3)**2-(PyP2+PyP3)**2-(PzP2+PzP3)**2))"
    > cout << FSTree::expandVariable("ABMASS(1,C)") << endl;
      // ==> "(sqrt((ABEnP1+ABEnPC)**2-(ABPxP1+ABPxPC)**2
                   -(ABPyP1+ABPyPC)**2-(ABPzP1+ABPzPC)**2))"
    > cout << FSTree::expandVariable("RECOILMASS(CM;D,2)") << endl;
      // ==> "(sqrt((EnPCM-(EnP2+EnPD))**2-(PxPCM-(PxP2+PxPD))**2
                   -(PyPCM-(PyP2+PyPD))**2-(PzPCM-(PzP2+PzPD))**2))"
\end{verbatim}
Histograms are automatically cached so they are made only once.  To save histograms at the end of a session, use the function:
\begin{verbatim}
    > FSHistogram::dumpHistogramCache(); 
\end{verbatim}
To read in the cache at the beginning of a session:
\begin{verbatim}
    > FSHistogram::readHistogramCache(); 
\end{verbatim}
To clear a cache from memory during a session:
\begin{verbatim}
    > FSHistogram::clearHistogramCache(); 
\end{verbatim}
To see more verbose output during a session:
\begin{verbatim}
    > FSControl::DEBUG = true;
\end{verbatim}

\subsection{Basic Tree Utilities the {\tt FSTree} class}
\label{sec:tree}

The {\tt FSTree} class is also located in the {\tt FSBasic} directory and provides basic utilities to operate on trees.  
Besides the static {\tt FSTree::expandVariable} member function mentioned in Sec.~\ref{sec:hist}, the most useful function is for skimming trees.  For example:
\begin{verbatim}
    > FSTree::skimTree(inputFileName, inputTreeName, outputFileName,
          "Chi2DOF<5.0"); 
\end{verbatim}
This will take the tree named {\tt inputTreeName} from the file {\tt inputFileName}, loop over all events and select only those that pass the cut on {\tt Chi2DOF}, then output the selected events to the file named {\tt outputFileName} in a tree with the same name as the input tree.  The shortcuts mentioned in Sec~\ref{sec:hist} can also be used here, for example:
\begin{verbatim}
    > FSTree::skimTree(inputFileName, inputTreeName, outputFileName,
          "abs(MASS(1,2)-0.5)<0.1"); 
\end{verbatim}


\section{Final State Operations:  the {\tt FSMode} directory}
\label{sec:modes}

\subsection{Mode Numbering and Conventions}
\label{sec:modeconv}

A ``final state''~(also called ``mode'') is made from a combination of: $\Lambda (\to p \pi^-)$, $\bar{\Lambda} (\to \bar{p} \pi^+)$, $e^+$, $e^-$, $\mu^+$, $\mu^-$, $p$, $\bar{p}$, $\eta (\to \gamma\gamma)$, $\gamma$, $K^+$, $K^-$, $K^0_S (\to \pi^+\pi^-)$, $\pi^+$, $\pi^-$, $\pi^0 (\to \gamma\gamma)$.

As strings, these final state particles are given as:
$\Lambda (\to p \pi^-) \equiv $~{\tt Lambda}, 
$\bar{\Lambda} (\to \bar{p} \pi^+) \equiv $~{\tt ALambda}, 
$e^+ \equiv $~{\tt e+}, 
$e^- \equiv $~{\tt e-}, 
$\mu^+ \equiv $~{\tt mu+},  
$\mu^- \equiv $~{\tt mu-}, 
$p \equiv $~{\tt p+}, 
$\bar{p} \equiv $~{\tt p-}, 
$\eta (\to \gamma\gamma) \equiv $~{\tt eta}, 
$\gamma \equiv $~{\tt gamma}, 
$K^+ \equiv $~{\tt K+}, 
$K^- \equiv $~{\tt K-}, 
$K^0_S (\to \pi^+\pi^-) \equiv $~{\tt Ks}, 
$\pi^+ \equiv $~{\tt pi+}, 
$\pi^- \equiv $~{\tt pi-}, 
$\pi^0 (\to \gamma\gamma) \equiv $~{\tt pi0}.

In a {\tt TTree}, the final state particles should be listed in the order they are given above.  The numbering for the {\tt [CD]} (Sec.~\ref{sec:conventions}) starts at ``1''.  For final state particles that decay~($\Lambda (\to p \pi^-) \equiv $~{\tt Lambda}, 
$\bar{\Lambda} (\to \bar{p} \pi^+) \equiv $~{\tt ALambda}, $\eta (\to \gamma\gamma) \equiv $~{\tt eta}, $K^0_S (\to \pi^+\pi^-) \equiv $~{\tt Ks}, $\pi^0 (\to \gamma\gamma) \equiv $~{\tt pi0}), the four-momenta of the decay particles are listed using ``a'' and ``b'' in the same order as above or ordered by energy for identical particles.

For example, for the final state $\gamma K^+ K^0_S \pi^+ \pi^- \pi^- \pi^0$, the four-momenta are:
\begin{verbatim}
    EnP1  PxP1  PyP1  PzP1     (for the gamma)
    EnP2  PxP2  PyP2  PzP2     (for the K+)
    EnP3  PxP3  PyP3  PzP3     (for the Ks)
    EnP3a PxP3a PyP3a PzP3a    (for the pi+ from Ks)
    EnP3b PxP3b PyP3b PzP3b    (for the pi- from Ks)
    EnP4  PxP4  PyP4  PzP4     (for the pi+)
    EnP5  PxP5  PyP5  PzP5     (for one pi-)
    EnP6  PxP6  PyP6  PzP6     (for the other pi-)
    EnP7  PxP7  PyP7  PzP7     (for the pi0)
    EnP7a PxP7a PyP7a PzP7a    (for the higher energy gamma from pi0)
    EnP7b PxP7b PyP7b PzP7b    (for the lower energy gamma from pi0)
\end{verbatim}





Every final state can be specified in three different ways:

(1) {\tt pair<int,int> modeCode}: a pair of two integers ({\tt modeCode1}, {\tt modeCode2}) that count the number of particles in a decay mode.
\begin{verbatim}
              modeCode1 = abcdefg
                  a = # gamma
                  b = # K+
                  c = # K-
                  d = # Ks
                  e = # pi+
                  f = # pi-
                  g = # pi0
              modeCode2 = abcdefghi
                  a = # Lambda
                  b = # ALambda
                  c = # e+
                  d = # e-
                  e = # mu+
                  f = # mu-
                  g = # p+
                  h = # p-
                  i = # eta
\end{verbatim}
(2) {\tt TString modeString}: a string version of {\tt modeCode1} and {\tt modeCode2} in the format ``{\tt modeCode2\_modeCode1}''.  It can contain a prefix (for example, ``FS'' or ``EXC'' or ``INC'' or anything longer) that isn't used here, but can help with organization elsewhere.  

(3) {\tt TString modeDescription}: a string with a list of space-separated particle names~(for example ``{\tt K+ K- pi+ pi+ pi- pi-}'').  The final state particles can appear in any order. 

For example, the final state $\gamma K^+ K^0_S \pi^+ \pi^- \pi^- \pi^0$ has {\tt modeCode1 = 1101121}, {\tt modeCode2 = 0}, {\tt modeString = "0\_1101121"}, {\tt modeDescription = "gamma K+ Ks pi+ pi- pi- pi0"}. 

\subsection{Mode Information: the {\tt FSModeInfo} class}
\label{sec:modeinfo}

Information about an individual final state is carried by the {\tt FSModeInfo} class.  Here are examples of a few of its basic member functions:
\begin{verbatim}
    > FSModeInfo mi("K+ K- K+ K- pi+ pi- pi0 eta");
    > mi.modeString();   // ==> "1_220111"
    > mi.modeCode1();    // ==> 220111
    > mi.modeCode2();    // ==> 1
    > mi.modeString("this is the code: (MODECODE1,MODECODE2)");
       // ==> "this is the code: (220111,1)" 
    > mi.modeString("MODESTRING corresponds to MODEDESCRIPTION");
       // ==> "1_220111 corresponds to  K+  K+  K-  K-  pi+  pi-  pi0  eta "
\end{verbatim}

The {\tt FSModeInfo} class also handles particle combinatorics within a given final state through the {\tt modeCombinatorics} member function.  This is done using placeholders like ``[pi+]'', ``[pi-]'', ``[K+]'', ``[K+3]'', ``[tk+]'', ``[pi0]'', etc., which are replaced by particle indices.  While the {\tt modeCombinatorics} function is rarely used explicitly by the user, it can be useful for cross-checking that the behavior of the combinatorics is what you want. For example:
\begin{verbatim}
    > mi.modeCombinatorics("K+[K+], K-[K-], K+(again)[K+], K+(other one)[K+2]",true);
      // ==>  *** MODE COMBINATORICS TEST ***
      // ==>  K+3, K-4, K+(again)3, K+(other one)2
      // ==>  K+3, K-5, K+(again)3, K+(other one)2
      // ==>  K+2, K-4, K+(again)2, K+(other one)3
      // ==>  K+2, K-5, K+(again)2, K+(other one)3
      // ==>  *******************************
\end{verbatim}

The {\tt modeCuts} member function uses the results of {\tt modeCombinatorics} to combine combinatorics into a single string using the keywords ``AND'' and ``OR'':
\begin{verbatim}
    > cout << mi.modeCuts("OR((ABC[K+]+DEF[K-])>0)") << endl;
      // ==>  "(((ABC2+DEF4)>0)||((ABC3+DEF4)>0)||((ABC2+DEF5)>0)||((ABC3+DEF5)>0))"
    > cout << mi.modeCuts("AND((ABC[K+]+DEF[K-])>0)") << endl;
      // ==>  "(((ABC2+DEF4)>0)&&((ABC3+DEF4)>0)&&((ABC2+DEF5)>0)&&((ABC3+DEF5)>0))"
\end{verbatim}

Note that most of the functionality of the {\tt FSModeInfo} class is rarely used explicitly.  It is more often combined with other functions and used in higher-level classes~(like {\tt FSModeHistogram}), often producing large strings~(used only internally), like:
\begin{verbatim}
    > FSTree::expandVariable(mi.modeCuts("AND(MASS2([K+],[K-])>MASS2([pi+],[K-]))"))
      // ==>  "((((EnP2+EnP4)**2-(PxP2+PxP4)**2-(PyP2+PyP4)**2-(PzP2+PzP4)**2)>
                 ((EnP4+EnP6)**2-(PxP4+PxP6)**2-(PyP4+PyP6)**2-(PzP4+PzP6)**2))&&
                (((EnP3+EnP4)**2-(PxP3+PxP4)**2-(PyP3+PyP4)**2-(PzP3+PzP4)**2)>
                 ((EnP4+EnP6)**2-(PxP4+PxP6)**2-(PyP4+PyP6)**2-(PzP4+PzP6)**2))&&
                (((EnP2+EnP5)**2-(PxP2+PxP5)**2-(PyP2+PyP5)**2-(PzP2+PzP5)**2)>
                 ((EnP5+EnP6)**2-(PxP5+PxP6)**2-(PyP5+PyP6)**2-(PzP5+PzP6)**2))&&
                (((EnP3+EnP5)**2-(PxP3+PxP5)**2-(PyP3+PyP5)**2-(PzP3+PzP5)**2)>
                 ((EnP5+EnP6)**2-(PxP5+PxP6)**2-(PyP5+PyP6)**2-(PzP5+PzP6)**2)))"
\end{verbatim} 

The {\tt FSModeInfo} object also contains a list of ``categories'' that are used by the {\tt FSModeCollection} class~(next section) for organization.  The {\tt display} method shows information about a given mode, including a list of categories, some of which are added by default.  In the following, the first use of {\tt display} will show the default list of categories; the second will also show the added categories:
\begin{verbatim}
    > mi.display();
      // ==>   0    1_220111    K+  K+  K-  K-  pi+  pi-  pi0  eta 
      // ==>                      Hadronic  HasGammas  HasEtas  HasKaons  
      // ==>                      HasPions  HasPi0s  1Eta4K2Pi1Pi0  8Body  
      // ==>                      4Gamma  CODE=1_220111  CODE1=220111  CODE2=1
    > mi.addCategory("TEST1");
    > mi.addCategory("TEST2");
    > mi.display();
      // ==>   0    1_220111    K+  K+  K-  K-  pi+  pi-  pi0  eta 
      // ==>                      Hadronic  HasGammas  HasEtas  HasKaons  
      // ==>                      HasPions  HasPi0s  1Eta4K2Pi1Pi0  8Body  
      // ==>                      4Gamma  CODE=1_220111  CODE1=220111  CODE2=1
      // ==>                      TEST1  TEST2
\end{verbatim}

\subsection{Collections of Modes: the {\tt FSModeCollection} class}
\label{sec:modecollection}

A list of final states~({\tt FSModeInfo} objects) is managed by the {\tt FSModeCollection} class.   Every final state is associated with a list of ``categories''. The {\tt FSModeCollection} class uses these categories to produce sublists.

\subsection{Histograms for Multiple Modes: the {\tt FSModeHistogram} class}
\label{sec:modehist}

\subsection{Operations on Multiple Trees: the {\tt FSModeTree} class}
\label{sec:modetree}


\section{Fitting Utilities:  the {\tt FSFit} directory}

The fitting utilities (contained in the directory {\tt FSFit}) work, but are still under development.  See the examples in the directory {\tt Examples/Fitting} to get the general idea.



\end{document}
