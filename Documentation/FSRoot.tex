\documentclass[11pt]{article}
%\usepackage{graphicx}
\usepackage{amssymb}
%\usepackage[]{epsfig}
%\usepackage{parskip}

\textheight 8.0in
\topmargin 0.0in
\textwidth 6.5in
\oddsidemargin 0.0in
\evensidemargin 0.0in

\newcommand{\FSR}{{\tt FSRoot}}
\newcommand{\ROOT}{{\tt ROOT}}
\newcommand{\git}{{\tt git}}

\begin{document}


\title{Notes on the \FSR\ Package}
\author{Ryan Mitchell}
\date{\today}
\maketitle

\abstract{
\FSR\ is a set of utilities to help manipulate information about different Final States~(FS) produced in particle physics experiments.  The utilities are built around the CERN \ROOT\ framework.  This document provides an introduction to \FSR.}

\tableofcontents

\parindent 0pt
\parskip 10pt



%\section{Overview of \FSR}

%This is an overview of \FSR.

\section{Installation and Initial Setup}

Instructions for installation and initial setup:

(1) Download the source:
\begin{verbatim}
    > git clone https://github.com/remitche66/FSRoot.git FSRoot
\end{verbatim}

(2) Set the location of \FSR\ in your login shell script (e.g. {\tt .cshrc}):
\begin{verbatim}
    setenv FSROOT [xxxxx]/FSRoot
\end{verbatim}

(3) Also probably add the \FSR\ directory to {\tt \$DYLD\_LIBRARY\_PATH} and {\tt \$LD\_LIBRARY\_PATH}.  This allows you to compile code including \FSR\ functions.  For example:
\begin{verbatim}
     setenv DYLD_LIBRARY_PATH $DYLD_LIBRARY_PATH\:$FSROOT
     setenv   LD_LIBRARY_PATH   $LD_LIBRARY_PATH\:$FSROOT
\end{verbatim}

(4) There is usually a {\tt .rootrc} file in your home directory that \ROOT\ uses for initialization.  Add lines like these to {\tt .rootrc}, which tell \ROOT\ the location of \FSR:
\begin{verbatim}
    Unix.*.Root.DynamicPath: .:$(FSROOT):$(ROOTSYS)/lib:
    Unix.*.Root.MacroPath:   .:$(FSROOT):
\end{verbatim}

(5) Now when you open \ROOT, the \FSR\ utilities should be loaded and compiled -- you should see a message saying ``Loading the FSRoot Macros'' along with the output of the compilation.  The loading and compiling is done in the file {\tt rootlogon.C}.  This file also sets up default styles, which are not essential.  Since these might conflict with styles you have defined elsewhere, it could be worthwhile to tweak or remove these.

\section{Basic Operations:  the {\tt FSBasic} directory}

\subsection{Basic Conventions}
\label{sec:conventions}

Some \FSR\ operations on variables within a \ROOT\ {\tt TTree} assume a particular format within the tree.  Four-vectors are assumed to take the form:
\begin{verbatim}
    [AB]EnP[CD], [AB]PxP[CD], [AB]PyP[CD], [AB]PzP[CD]
\end{verbatim}
where {\tt [CD]} is a particle label (often ``1'', ``2'', ``3'', ``2a'', etc., but also ``CM'' or ``B'' or other) and {\tt [AB]} labels the type of four-vector (for example, ``R'' for raw or ``K'' for kinematically fit or ``MC'' for Monte Carlo, etc.).  The \FSR\ code does not assume anything about the conventions for {\tt [CD]} and {\tt [AB]}.

Variable names for run numbers, event numbers, and the $\chi^2$/dof from a kinematic fit are also hardcoded in a couple of places:
\begin{verbatim}
    Run, Event, Chi2DOF
\end{verbatim}
Maybe a future version of \FSR\ could make these formats customizable.


\subsection{Basic Histogram Utilities}
\label{sec:hist}

Basic histogram functions are provided by the {\tt FSHistogram} class in the {\tt FSBasic} directory.  Like many other functions within \FSR, the functions within the {\tt FSHistogram} class are static member functions, so there is never a need to deal with instances of {\tt FSHistogram}.

The basic functionality is through the {\tt FSHistogram::getTH1F} and {\tt FSHistogram::getTH2F} classes.  Here are example uses that can be run from either the \ROOT\ command line or from a macro~(see {\tt Examples/Intro/intro.C}).  The first draws a 1d histogram and the second draws a 2d histogram.  The third argument is the variable to plot; the fourth holds the number of bins and bounds.
\begin{verbatim}
    > FSHistogram::getTH1F(FileName,TreeName,"Chi2DOF","(60,0.0,6.0)","")->Draw();
    > FSHistogram::getTH2F(FileName,TreeName,"Chi2DOF:Event",
          "(100,0.0,1.0e6,60,0.0,6.0)","")->Draw("colz");
\end{verbatim}
Cuts can be added in the fifth argument:
\begin{verbatim}
    > FSHistogram::getTH1F(FileName,TreeName,"Chi2DOF",
        "(60,0.0,6.0)","Chi2DOF<5.0")->Draw();
\end{verbatim}
The variable and cut arguments can contain shortcuts.  For example, {\tt MASS(I,J)} is expanded into the total invariant mass of particles {\tt I} and {\tt J}, where {\tt I} and {\tt J} are not necessarily numbers~(they are the {\tt [CD]} in Sec.~\ref{sec:conventions}).  Characters in front of {\tt MASS}~(for example) are prepended to the variable names (the {\tt [AB]} in Sec.~\ref{sec:conventions}).  This is all done in the function {\tt FSTree::expandVariable}, which can also be used on its own to explicitly see what it is doing.    See {\tt FSTree::expandVariable} for more options beyond {\tt MASS}~(for example, {\tt RECOILMASS}, {\tt MOMENTUM}, {\tt COSINE}, etc.).  Examples:
\begin{verbatim}
    > FSHistogram::getTH1F(FileName,TreeName,"MASS(1,2)",
        "(60,0.0,6.0)","Chi2DOF<5.0&&MASS(1,2)>1.0")->Draw();
    > cout << FSTree::expandVariable("MASS(1,2)+MASS(2,3)") << endl;
    > cout << FSTree::expandVariable("ABMASS(1,C)") << endl;
    > cout << FSTree::expandVariable("RECOILMASS(CM;D,2)") << endl;
\end{verbatim}
Histograms are automatically cached so they are made only once.  To save histograms at the end of a session, use the function:
\begin{verbatim}
    > FSHistogram::dumpHistogramCache(); 
\end{verbatim}
To read in the cache at the beginning of a session:
\begin{verbatim}
    > FSHistogram::readHistogramCache(); 
\end{verbatim}
To clear a cache from memory during a session:
\begin{verbatim}
    > FSHistogram::clearHistogramCache(); 
\end{verbatim}
To see more verbose output during a session:
\begin{verbatim}
    > FSControl::DEBUG = true;
\end{verbatim}

\subsection{Basic Tree Utilities}
\label{sec:tree}

The {\tt FSTree} class is also located in the {\tt FSBasic} directory and provides basic utilities to operate on trees.  
Besides the static {\tt FSTree::expandVariable} member function mentioned in Sec.~\ref{sec:hist}, the most useful function is for skimming trees.  For example:
\begin{verbatim}
    > FSTree::skimTree(inputFileName, inputTreeName, outputFileName,
          "Chi2DOF<5.0"); 
\end{verbatim}
will take the tree named {\tt inputTreeName} from the file {\tt inputFileName}, loop over all events and select only those that pass the cut on {\tt Chi2DOF}, then output the selected events to the file named {\tt outputFileName} in a tree with the same name as the input tree.  The shortcuts mentioned in Sec~\ref{sec:hist} can also be used here, for example:
\begin{verbatim}
    > FSTree::skimTree(inputFileName, inputTreeName, outputFileName,
          "abs(MASS(1,2)-0.5)<0.1"); 
\end{verbatim}

\section{Final State Operations:  the {\tt FSMode} directory}


\subsection{Mode Numbering and Conventions}

A ``final state''~(also called ``mode'') is made from a combination of: $\Lambda (\to p \pi^-)$, $\bar{\Lambda} (\to \bar{p} \pi^+)$, $e^+$, $e^-$, $\mu^+$, $\mu^-$, $p$, $\bar{p}$, $\eta (\to \gamma\gamma)$, $\gamma$, $K^+$, $K^-$, $K^0_S (\to \pi^+\pi^-)$, $\pi^+$, $\pi^-$, $\pi^0 (\to \gamma\gamma)$.

As strings, these final state particles are given as:
$\Lambda (\to p \pi^-) \equiv $~{\tt Lambda}, 
$\bar{\Lambda} (\to \bar{p} \pi^+) \equiv $~{\tt ALambda}, 
$e^+ \equiv $~{\tt e+}, 
$e^- \equiv $~{\tt e-}, 
$\mu^+ \equiv $~{\tt mu+},  
$\mu^- \equiv $~{\tt mu-}, 
$p \equiv $~{\tt p+}, 
$\bar{p} \equiv $~{\tt p-}, 
$\eta (\to \gamma\gamma) \equiv $~{\tt eta}, 
$\gamma \equiv $~{\tt gamma}, 
$K^+ \equiv $~{\tt K+}, 
$K^- \equiv $~{\tt K-}, 
$K^0_S (\to \pi^+\pi^-) \equiv $~{\tt Ks}, 
$\pi^+ \equiv $~{\tt pi+}, 
$\pi^- \equiv $~{\tt pi-}, 
$\pi^0 (\to \gamma\gamma) \equiv $~{\tt pi0}.

Every final state can be specified in three different ways:

(1) {\tt pair<int,int> modeCode}: a pair of two integers ({\tt code1}, {\tt code2}) that count the number of particles in a decay mode.
\begin{verbatim}
              code1 = abcdefg
                  a = # gamma
                  b = # K+
                  c = # K-
                  d = # Ks
                  e = # pi+
                  f = # pi-
                  g = # pi0
              code2 = abcdefghi
                  a = # Lambda
                  b = # ALambda
                  c = # e+
                  d = # e-
                  e = # mu+
                  f = # mu-
                  g = # p+
                  h = # p-
                  i = # eta
\end{verbatim}
(2) {\tt TString modeString}: a string version of {\tt code1} and {\tt code2} in the format ``{\tt code2\_code1}''.  It can contain a prefix (for example, ``FS'' or ``EXC'' or ``INC'' or anything longer) that isn't used here, but can help with organization elsewhere.

(3) {\tt TString modeDescription}: a string with a list of space-separated particle names~(for example ``{\tt K+ K- pi+ pi+ pi- pi-}'').



\section{Fitting Utilities:  the {\tt FSFit} directory}

The fitting utilities (contained in the directory {\tt FSFit}) work, but are still under development.  See the examples in the directory {\tt Examples/Fitting} to get the general idea.



\end{document}
