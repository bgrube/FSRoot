\documentclass[11pt]{article}
%\usepackage{graphicx}
\usepackage{amssymb}
%\usepackage[]{epsfig}
%\usepackage{parskip}

\textheight 8.0in
\topmargin 0.0in
\textwidth 6.5in
\oddsidemargin 0.0in
\evensidemargin 0.0in

\newcommand{\FSR}{{\tt FSRoot}}
\newcommand{\ROOT}{{\tt ROOT}}
\newcommand{\git}{{\tt git}}

\begin{document}


\title{Notes on the \FSR\ Package}
\author{Ryan Mitchell}
\date{\today}
\maketitle

\abstract{
\FSR\ is a set of utilities to help manipulate information about different Final States~(FS) produced in particle physics experiments.  The utilities are built around the CERN \ROOT\ framework.  This document provides an introduction to \FSR.}

\tableofcontents

\parindent 0pt
\parskip 10pt



%\section{Overview of \FSR}

%This is an overview of \FSR.

\section{Installation and Initial Setup}

Instructions for installation and initial setup:

(1) Download the source:
\begin{verbatim}
    > git clone https://github.com/remitche66/FSRoot.git FSRoot
\end{verbatim}

(2) Set the location of \FSR\ in your login shell script (e.g. {\tt .cshrc}):
\begin{verbatim}
    setenv FSROOT [xxxxx]/FSRoot
\end{verbatim}

(3) Also probably add the \FSR\ directory to {\tt \$DYLD\_LIBRARY\_PATH} and {\tt \$LD\_LIBRARY\_PATH}.  This allows you to compile code including \FSR\ functions.  For example:
\begin{verbatim}
     setenv DYLD_LIBRARY_PATH $DYLD_LIBRARY_PATH\:$FSROOT
     setenv   LD_LIBRARY_PATH   $LD_LIBRARY_PATH\:$FSROOT
\end{verbatim}

(4) There is usually a {\tt .rootrc} file in your home directory that \ROOT\ uses for initialization.  Add lines like these to {\tt .rootrc}, which tell \ROOT\ the location of \FSR:
\begin{verbatim}
    Unix.*.Root.DynamicPath: .:$(FSROOT):$(ROOTSYS)/lib:
    Unix.*.Root.MacroPath:   .:$(FSROOT):
\end{verbatim}

(5) Now when you open \ROOT, the \FSR\ utilities should be loaded and compiled -- you should see a message saying ``Loading the FSRoot Macros'' along with the output of the compilation.  The loading and compiling is done in the file {\tt rootlogon.C}.  This file also sets up default styles, which are not essential.  Since these might conflict with styles you have defined elsewhere, it could be worthwhile to tweak or remove these.

\section{Basic Operations:  the {\tt FSBasic} directory}

\subsection{Basic Conventions}
\label{sec:conventions}

Some \FSR\ operations on variables within a \ROOT\ {\tt TTree} assume a particular format within the tree.  Four-vectors are assumed to take the form:
\begin{verbatim}
    [AB]EnP[CD], [AB]PxP[CD], [AB]PyP[CD], [AB]PzP[CD]
\end{verbatim}
where {\tt [CD]} is a particle label (often ``1'', ``2'', ``3'', ``2a'', etc., but also ``CM'' or ``B'' or other) and {\tt [AB]} labels the type of four-vector (for example, ``R'' for raw or ``K'' for kinematically fit or ``MC'' for Monte Carlo, etc.).  The \FSR\ code does not assume anything about the conventions for {\tt [AB]}.  The final state utilities described in Sec.~\ref{sec:modes} require the particles appear in a given order and assume a numbering convention for {\tt [CD]}, described in Sec.~\ref{sec:modeconv}.  The utilities described in this section do not assume a specific form for {\tt [CD]}.

Variable names for run numbers, event numbers, and the $\chi^2$/dof from a kinematic fit are also hardcoded in a couple of places (like in the functions that rank combinations within an event by $\chi^2/dof$):
\begin{verbatim}
    Run, Event, Chi2DOF
\end{verbatim}
Maybe a future version of \FSR\ could make these formats customizable.


\subsection{Basic Histogram Utilities: the {\tt FSHistogram} class}
\label{sec:hist}

Basic histogram functions are provided by the {\tt FSHistogram} class in the {\tt FSBasic} directory.  Like many other functions within \FSR, the functions within the {\tt FSHistogram} class are static member functions, so there is never a need to deal with instances of {\tt FSHistogram}.

The basic functionality is through the {\tt FSHistogram::getTH1F} and {\tt FSHistogram::getTH2F} classes.  Here are example uses that can be run from either the \ROOT\ command line or from a macro~(see {\tt Examples/Intro/intro.C}).  The first draws a 1d histogram and the second draws a 2d histogram.  The third argument is the variable to plot; the fourth holds the number of bins and bounds.
\begin{verbatim}
    > FSHistogram::getTH1F(FileName,TreeName,"Chi2DOF","(60,0.0,6.0)","")->Draw();
    > FSHistogram::getTH2F(FileName,TreeName,"Chi2DOF:Event",
          "(100,0.0,1.0e6,60,0.0,6.0)","")->Draw("colz");
\end{verbatim}
Cuts can be added in the fifth argument:
\begin{verbatim}
    > FSHistogram::getTH1F(FileName,TreeName,"Chi2DOF",
        "(60,0.0,6.0)","Chi2DOF<5.0")->Draw();
\end{verbatim}
The variable and cut arguments can contain shortcuts.  For example, {\tt MASS(I,J)} is expanded into the total invariant mass of particles {\tt I} and {\tt J}, where {\tt I} and {\tt J} are not necessarily numbers~(they are the {\tt [CD]} in Sec.~\ref{sec:conventions}).  Characters in front of {\tt MASS}~(for example) are prepended to the variable names (the {\tt [AB]} in Sec.~\ref{sec:conventions}).  This is all done in the function {\tt FSTree::expandVariable}, which can also be used on its own to explicitly see what it is doing.    See {\tt FSTree::expandVariable} for more options beyond {\tt MASS}~(for example, {\tt RECOILMASS}, {\tt MOMENTUM}, {\tt COSINE}, etc.).  Examples:
\begin{verbatim}
    > FSHistogram::getTH1F(FileName,TreeName,"MASS(1,2)",
        "(60,0.0,6.0)","Chi2DOF<5.0&&MASS(1,2)>1.0")->Draw();
    > cout << FSTree::expandVariable("MASS(1,2)+MASS(2,3)") << endl;
    > cout << FSTree::expandVariable("ABMASS(1,C)") << endl;
    > cout << FSTree::expandVariable("RECOILMASS(CM;D,2)") << endl;
\end{verbatim}
Histograms are automatically cached so they are made only once.  To save histograms at the end of a session, use the function:
\begin{verbatim}
    > FSHistogram::dumpHistogramCache(); 
\end{verbatim}
To read in the cache at the beginning of a session:
\begin{verbatim}
    > FSHistogram::readHistogramCache(); 
\end{verbatim}
To clear a cache from memory during a session:
\begin{verbatim}
    > FSHistogram::clearHistogramCache(); 
\end{verbatim}
To see more verbose output during a session:
\begin{verbatim}
    > FSControl::DEBUG = true;
\end{verbatim}

\subsection{Basic Tree Utilities the {\tt FSTree} class}
\label{sec:tree}

The {\tt FSTree} class is also located in the {\tt FSBasic} directory and provides basic utilities to operate on trees.  
Besides the static {\tt FSTree::expandVariable} member function mentioned in Sec.~\ref{sec:hist}, the most useful function is for skimming trees.  For example:
\begin{verbatim}
    > FSTree::skimTree(inputFileName, inputTreeName, outputFileName,
          "Chi2DOF<5.0"); 
\end{verbatim}
will take the tree named {\tt inputTreeName} from the file {\tt inputFileName}, loop over all events and select only those that pass the cut on {\tt Chi2DOF}, then output the selected events to the file named {\tt outputFileName} in a tree with the same name as the input tree.  The shortcuts mentioned in Sec~\ref{sec:hist} can also be used here, for example:
\begin{verbatim}
    > FSTree::skimTree(inputFileName, inputTreeName, outputFileName,
          "abs(MASS(1,2)-0.5)<0.1"); 
\end{verbatim}


\section{Final State Operations:  the {\tt FSMode} directory}
\label{sec:modes}

\subsection{Mode Numbering and Conventions}
\label{sec:modeconv}

A ``final state''~(also called ``mode'') is made from a combination of: $\Lambda (\to p \pi^-)$, $\bar{\Lambda} (\to \bar{p} \pi^+)$, $e^+$, $e^-$, $\mu^+$, $\mu^-$, $p$, $\bar{p}$, $\eta (\to \gamma\gamma)$, $\gamma$, $K^+$, $K^-$, $K^0_S (\to \pi^+\pi^-)$, $\pi^+$, $\pi^-$, $\pi^0 (\to \gamma\gamma)$.

As strings, these final state particles are given as:
$\Lambda (\to p \pi^-) \equiv $~{\tt Lambda}, 
$\bar{\Lambda} (\to \bar{p} \pi^+) \equiv $~{\tt ALambda}, 
$e^+ \equiv $~{\tt e+}, 
$e^- \equiv $~{\tt e-}, 
$\mu^+ \equiv $~{\tt mu+},  
$\mu^- \equiv $~{\tt mu-}, 
$p \equiv $~{\tt p+}, 
$\bar{p} \equiv $~{\tt p-}, 
$\eta (\to \gamma\gamma) \equiv $~{\tt eta}, 
$\gamma \equiv $~{\tt gamma}, 
$K^+ \equiv $~{\tt K+}, 
$K^- \equiv $~{\tt K-}, 
$K^0_S (\to \pi^+\pi^-) \equiv $~{\tt Ks}, 
$\pi^+ \equiv $~{\tt pi+}, 
$\pi^- \equiv $~{\tt pi-}, 
$\pi^0 (\to \gamma\gamma) \equiv $~{\tt pi0}.

In a {\tt TTree}, the final state particles should be listed in the order they are given above.  The numbering for the {\tt [CD]} (Sec.~\ref{sec:conventions}) starts at ``1''.  For final state particles that decay~($\Lambda (\to p \pi^-) \equiv $~{\tt Lambda}, 
$\bar{\Lambda} (\to \bar{p} \pi^+) \equiv $~{\tt ALambda}, $\eta (\to \gamma\gamma) \equiv $~{\tt eta}, $K^0_S (\to \pi^+\pi^-) \equiv $~{\tt Ks}, $\pi^0 (\to \gamma\gamma) \equiv $~{\tt pi0}), the four-momenta of the decay particles are listed using ``a'' and ``b'' in the same order as above or ordered by energy for identical particles.

For example, for the final state $\gamma K^+ K^0_S \pi^+ \pi^- \pi^0$, the four-momenta are:
\begin{verbatim}
    EnP1  PxP1  PyP1  PzP1     (for the gamma)
    EnP2  PxP2  PyP2  PzP2     (for the K+)
    EnP3  PxP3  PyP3  PzP3     (for the Ks)
    EnP3a PxP3a PyP3a PzP3a    (for the pi+ from Ks)
    EnP3b PxP3b PyP3b PzP3b    (for the pi- from Ks)
    EnP4  PxP4  PyP4  PzP4     (for the pi+)
    EnP5  PxP5  PyP5  PzP5     (for the pi-)
    EnP6  PxP6  PyP6  PzP6     (for the pi0)
    EnP6a PxP6a PyP6a PzP6a    (for the higher energy gamma from pi0)
    EnP6b PxP6b PyP6b PzP6b    (for the lower energy gamma from pi0)
\end{verbatim}





Every final state can be specified in three different ways:

(1) {\tt pair<int,int> modeCode}: a pair of two integers ({\tt modeCode1}, {\tt modeCode2}) that count the number of particles in a decay mode.
\begin{verbatim}
              modeCode1 = abcdefg
                  a = # gamma
                  b = # K+
                  c = # K-
                  d = # Ks
                  e = # pi+
                  f = # pi-
                  g = # pi0
              modeCode2 = abcdefghi
                  a = # Lambda
                  b = # ALambda
                  c = # e+
                  d = # e-
                  e = # mu+
                  f = # mu-
                  g = # p+
                  h = # p-
                  i = # eta
\end{verbatim}
(2) {\tt TString modeString}: a string version of {\tt modeCode1} and {\tt modeCode2} in the format ``{\tt modeCode2\_modeCode1}''.  It can contain a prefix (for example, ``FS'' or ``EXC'' or ``INC'' or anything longer) that isn't used here, but can help with organization elsewhere.  

(3) {\tt TString modeDescription}: a string with a list of space-separated particle names~(for example ``{\tt K+ K- pi+ pi+ pi- pi-}'').  The final state particles can appear in any order. 

For example, the final state $\gamma K^+ K^0_S \pi^+ \pi^- \pi^0$ has {\tt modeCode1 = 1101111}, {\tt modeCode2 = 0}, {\tt modeString = "ANYTHING\_0\_1101111"}, {\tt modeDescription = "gamma K+ Ks pi+ pi- pi0"}. 

\subsection{Mode Information: the {\tt FSModeInfo} class}

\begin{verbatim}
    > FSModeInfo mi("K+ K- K+ K- pi+ pi- pi0 eta");
    > mi.modeString();   // ==> "1_220111"
    > mi.modeCode1();    // ==> 220111
    > mi.modeCode2();    // ==> 1
    > mi.modeString("this is the code: (MODECODE1,MODECODE2)");
                    // ==> "this is the code: (220111,1)" 
\end{verbatim}


\begin{verbatim}
    > mi.modeCombinatorics("ABC[K+] DEF[K-]",true);
      // ==>  *** MODE COMBINATORICS TEST ***
      // ==>  ABC2 DEF4
      // ==>  ABC3 DEF4
      // ==>  ABC2 DEF5
      // ==>  ABC3 DEF5
      // ==>  *******************************
\end{verbatim}

\begin{verbatim}
    > mi.modeCuts("OR((ABC[K+]+DEF[K-])>0)");
      // ==>  "(((ABC2+DEF4)>0)||((ABC3+DEF4)>0)||((ABC2+DEF5)>0)||((ABC3+DEF5)>0))"
\end{verbatim}


\subsection{Collections of Modes: the {\tt FSModeCollection} class}

\subsection{Histograms for Multiple Modes: the {\tt FSModeHistogram} class}

\subsection{Operations on Multiple Trees: the {\tt FSModeTree} class}

\section{Fitting Utilities:  the {\tt FSFit} directory}

The fitting utilities (contained in the directory {\tt FSFit}) work, but are still under development.  See the examples in the directory {\tt Examples/Fitting} to get the general idea.



\end{document}
